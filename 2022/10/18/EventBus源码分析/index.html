<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="android," />





  <link rel="alternate" href="/atom.xml" title="yndongyong‘s blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="是什么 EventBus is a publish&#x2F;subscribe event bus for Android and Java.  EventBus 是基于发布-订阅模式（也叫观察模式）的事件总线框架。在Android开发中，常用于组件之间的通信与数据传输，可以有效的进行组件之间的解耦。例如，Activity之间、与Fragment的参数传递，事件通知等。 有什么特点 使用简单，如">
<meta property="og:type" content="article">
<meta property="og:title" content="EventBus源码分析">
<meta property="og:url" content="https://yndongyong.github.io/2022/10/18/EventBus%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="yndongyong‘s blog">
<meta property="og:description" content="是什么 EventBus is a publish&#x2F;subscribe event bus for Android and Java.  EventBus 是基于发布-订阅模式（也叫观察模式）的事件总线框架。在Android开发中，常用于组件之间的通信与数据传输，可以有效的进行组件之间的解耦。例如，Activity之间、与Fragment的参数传递，事件通知等。 有什么特点 使用简单，如">
<meta property="og:locale">
<meta property="article:published_time" content="2022-10-18T08:05:11.000Z">
<meta property="article:modified_time" content="2022-11-08T09:43:07.755Z">
<meta property="article:author" content="yndongyong">
<meta property="article:tag" content="android">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yndongyong.github.io/2022/10/18/EventBus源码分析/"/>





  <title>EventBus源码分析 | yndongyong‘s blog</title>
  














<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">yndongyong‘s blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">生命不息，学习不止！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://yndongyong.github.io/2022/10/18/EventBus%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yndongyong‘s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">EventBus源码分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-10-18T16:05:11+08:00">
                2022-10-18
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2022-11-08T17:43:07+08:00">
                2022-11-08
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/EventBus/" itemprop="url" rel="index">
                    <span itemprop="name">EventBus</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><blockquote>
<p>EventBus is a publish&#x2F;subscribe event bus for Android and Java.</p>
</blockquote>
<p>EventBus 是基于发布-订阅模式（也叫观察模式）的事件总线框架。在Android开发中，常用于组件之间的通信与数据传输，可以有效的进行组件之间的解耦。例如，Activity之间、与Fragment的参数传递，事件通知等。</p>
<h3 id="有什么特点"><a href="#有什么特点" class="headerlink" title="有什么特点"></a>有什么特点</h3><ul>
<li><p>使用简单，如果这也算一个优点的话。相比LocalBroadcastManager使用是真的简单。</p>
</li>
<li><p>有五种线程模式，支持订阅方法执行在指定的线程。</p>
</li>
<li><p>可以指定订阅者的优先级，按优先级处理事件，还可以拦截事件。</p>
</li>
<li><p>3.0版本之前使用的运行时的反射收集事件的订阅方法，有一定的性能损耗，但3.0之后使用了Apt技术，编译时期就完成了订阅事件的收集。</p>
</li>
</ul>
<h3 id="有什么缺点"><a href="#有什么缺点" class="headerlink" title="有什么缺点"></a>有什么缺点</h3><ul>
<li>没有生命周期感知的功能</li>
</ul>
<p>注册和反注册需要成对的出现，如果忘记反注册可能会导致内存泄漏的问题发生，特别是在Activity、Fragment中使用时。毕竟这个框架出现的时间可比LifeCycle出现的早很多了。</p>
<ul>
<li>不克制使用的话，会造成大量事件的满天飞，同时也导致POJO类的膨胀。</li>
</ul>
<p>需要为Event事件专门定义java类，针对数据传输的场景，难以复用Event。</p>
<h3 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h3><p>使用方式就不介绍了，参见官网：<a target="_blank" rel="noopener" href="http://greenrobot.org/eventbus/">http://greenrobot.org/eventbus/</a></p>
<h3 id="是如何运行的"><a href="#是如何运行的" class="headerlink" title="是如何运行的"></a>是如何运行的</h3><p>基于3.6.0版本进行源码分析。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>Event ：事件，分为普通事件和粘性事件（StickyEvent），通常定义为一个键的pojo类。</li>
<li>Publisher：发布者，使用post方法发布事件。</li>
<li>Subscriber：订阅者，订阅关心的Event，在指定的线程执行。</li>
</ul>
<p>先贴出一下EventBus类中的几个关键的缓存map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class EventBus &#123;</span><br><span class="line"></span><br><span class="line">    static volatile EventBus defaultInstance;</span><br><span class="line"></span><br><span class="line">    private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();</span><br><span class="line">    //key:event class ,values:event class 已经event class的父类</span><br><span class="line">    private static final Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; eventTypesCache = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    //    key:event，values:订阅了某个事件的所有订阅者的集合</span><br><span class="line">    private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line">    //    key:订阅者，values:订阅的所有event class</span><br><span class="line">    private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line">    //粘性事件，key:eventType class ：事件对象 ，粘性消息重复添加的话，只会保存最后一个</span><br><span class="line">    private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注册订阅者"><a href="#注册订阅者" class="headerlink" title="注册订阅者"></a>注册订阅者</h4><p>入口在Eventbus的register</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object subscriber)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (AndroidDependenciesDetector.isAndroidSDKAvailable() &amp;&amp; !AndroidDependenciesDetector.areAndroidComponentsAvailable()) &#123;</span><br><span class="line">            <span class="comment">// Crash if the user (developer) has not imported the Android compatibility library.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;It looks like you are using EventBus on Android, &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;make sure to add the \&quot;eventbus\&quot; Android library to your dependencies.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    <span class="comment">//步骤1</span></span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">                <span class="comment">//步骤2</span></span><br><span class="line">                subscribe(subscriber, subscriberMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="收集事件订阅"><a href="#收集事件订阅" class="headerlink" title="收集事件订阅"></a>收集事件订阅</h4><p>拿到<code>subscriber</code>的class，使用<code>subscriberMethodFinder</code>找出当前class以及父类下的所有订阅方法，跟一下<code>findSubscriberMethods</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SubscriberMethod&gt; <span class="title function_">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> &#123;</span><br><span class="line"><span class="comment">//        从缓存中找 事件的处理方法集合</span></span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">        <span class="keyword">if</span> (subscriberMethods != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//evebuts 3.0 之前逻辑,反射收集</span></span><br><span class="line">        <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">            subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//3.0之后的版本使用apt，编译时就生成了索引类，</span></span><br><span class="line">            <span class="comment">//索引类的添加EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus();</span></span><br><span class="line">            subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//进行了注册，但是没有@Subscriber的方法，就抛出异常。</span></span><br><span class="line">        <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;Subscriber &quot;</span> + subscriberClass</span><br><span class="line">                    + <span class="string">&quot; and its super classes have no public methods with the @Subscribe annotation&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">            <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>先看一下<code>HEAD_CACHE</code>的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//    key:订阅者类，values：某一事件的所有处理方法的集合</span><br><span class="line">    private static final Map&lt;Class&lt;?&gt;, List&lt;SubscriberMethod&gt;&gt; METHOD_CACHE = new ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>查找时，先从<code>METHOD_CACHE</code>缓存中查找，在<code>METHOD_CACHE</code>缓存没有命中时，3.0之前的版本使用反射的方式查找，3.0的版本冲Apt时期生成的索引类中的查找。找到是放入<code>METHOD_CACHE</code>中。</p>
<p>在进行重复注册与反注册的场景，可以有效避免反复查找的问题，比如，一个事件只在<code>Activity</code>可见阶段才感兴趣的情况，就会在<code>onResume</code>生命周期进行注册，在<code>onPause</code>的生命周期进行反注册。这个空间换时间的缓存机制，就可以避免二次查找。</p>
<h5 id="3-0之前反射方式"><a href="#3-0之前反射方式" class="headerlink" title="3.0之前反射方式"></a>3.0之前反射方式</h5><p>看一下3.0之前的反射方式的，主要跟一下<code>findUsingReflection</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title function_">findUsingReflection</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> &#123;</span><br><span class="line"><span class="comment">//        prepareFindState object pool 防止频繁创建对象，</span></span><br><span class="line">        <span class="type">FindState</span> <span class="variable">findState</span> <span class="operator">=</span> prepareFindState();</span><br><span class="line">        findState.initForSubscriber(subscriberClass);</span><br><span class="line"><span class="comment">//        clazz 订阅者，或者订阅者的分类</span></span><br><span class="line">        <span class="keyword">while</span> (findState.clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//通过反射 收集订阅者的事件处理方法</span></span><br><span class="line">            findUsingReflectionInSingleClass(findState);</span><br><span class="line">            <span class="comment">//在父类中，收集一遍，直接系统类时，clazz = false,结束递归</span></span><br><span class="line">            findState.moveToSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回事件处理集合，并且重置findState，将尝试将findState放回对象池中</span></span><br><span class="line">        <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用迭代的方式，收集订阅者以及父类中的订阅方法，直到找到系统类是退出迭代。</p>
<p><code>FindState</code>用于存放查找过程中的各种现相关信息，使用了对象池，避免频繁的对象创建，又再一次用空间换时间，同时也可以避免频繁的GC，造成内存抖动，引起卡顿。</p>
<p>该类的部分源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FindState</span> &#123;</span><br><span class="line">        <span class="comment">//当前订阅类以及父类中，事件的所有处理订阅方法</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//key：eventType,value: eventType的处理的方法</span></span><br><span class="line">        <span class="keyword">final</span> Map&lt;Class, Object&gt; anyMethodByEventType = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//key：处理方法的字符串化，value：订阅类</span></span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, Class&gt; subscriberClassByMethodKey = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">StringBuilder</span> <span class="variable">methodKeyBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//订阅者</span></span><br><span class="line">        Class&lt;?&gt; subscriberClass;</span><br><span class="line"><span class="comment">//        订阅者的父类，有可能有</span></span><br><span class="line">        Class&lt;?&gt; clazz;</span><br><span class="line">        <span class="type">boolean</span> skipSuperClasses;</span><br><span class="line">     <span class="comment">//APT先关的索引信息</span></span><br><span class="line">        SubscriberInfo subscriberInfo;</span><br></pre></td></tr></table></figure>

<p>之后就到了<code>findUsingReflectionInSingleClass</code>方法。见名知意。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> &#123;</span><br><span class="line">        Method[] methods;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></span><br><span class="line">            methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">            <span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                methods = findState.clazz.getMethods();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LinkageError error) &#123; <span class="comment">// super class of NoClassDefFoundError to be a bit more broad...</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Could not inspect methods of &quot;</span> + findState.clazz.getName();</span><br><span class="line">                <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">                    msg += <span class="string">&quot;. Please consider using EventBus annotation processor to avoid reflection.&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    msg += <span class="string">&quot;. Please make this class visible to EventBus annotation processor to avoid reflection.&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(msg, error);</span><br><span class="line">            &#125;</span><br><span class="line">            findState.skipSuperClasses = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        从这里可以看出来，为啥处理事件的方法需要是定义为public，已经方法参数只能有一个的要求，因为反射的查找的缘故。</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> method.getModifiers();</span><br><span class="line"><span class="comment">//            只能是public，非静态、非抽象类</span></span><br><span class="line">            <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">                <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="type">Subscribe</span> <span class="variable">subscribeAnnotation</span> <span class="operator">=</span> method.getAnnotation(Subscribe.class);</span><br><span class="line">                    <span class="keyword">if</span> (subscribeAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">                        Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                        <span class="comment">//关键点1</span></span><br><span class="line">                        <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                            <span class="type">ThreadMode</span> <span class="variable">threadMode</span> <span class="operator">=</span> subscribeAnnotation.threadMode();</span><br><span class="line">                            <span class="comment">//将方法、event、threadmod、优先级、是否是粘性包装到SubscriberMethod中</span></span><br><span class="line">                            findState.subscriberMethods.add(<span class="keyword">new</span> <span class="title class_">SubscriberMethod</span>(method, eventType, threadMode,</span><br><span class="line">                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getDeclaringClass().getName() + <span class="string">&quot;.&quot;</span> + method.getName();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;@Subscribe method &quot;</span> + methodName +</span><br><span class="line">                            <span class="string">&quot;must have exactly 1 parameter but has &quot;</span> + parameterTypes.length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getDeclaringClass().getName() + <span class="string">&quot;.&quot;</span> + method.getName();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(methodName +</span><br><span class="line">                        <span class="string">&quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>找到<code>@Subscribe</code>注解的非<code>static</code>的、<code>public</code>的，有且仅有一个参数的方法，包装到<code>SubscriberMethod</code>中，解析ThreadMode、优先级priority、是否是粘性事件。</p>
<p>其中<code>findState.checkAdd(method, eventType)</code>,处理了子类和父类中，是否存在订阅方法重新的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查了子类是否有重写重复的方法。有的话需要使用之类的方法。</span></span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">checkAdd</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> &#123;</span><br><span class="line">            <span class="comment">// 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.</span></span><br><span class="line">            <span class="comment">// Usually a subscriber doesn&#x27;t have methods listening to the same event type.</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">existing</span> <span class="operator">=</span> anyMethodByEventType.put(eventType, method);</span><br><span class="line">            <span class="keyword">if</span> (existing == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> Method) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!checkAddWithMethodSignature((Method) existing, eventType)) &#123;</span><br><span class="line">                        <span class="comment">// Paranoia check</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Put any non-Method object to &quot;consume&quot; the existing Method</span></span><br><span class="line">                    anyMethodByEventType.put(eventType, <span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> checkAddWithMethodSignature(method, eventType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-0之后APT技术"><a href="#3-0之后APT技术" class="headerlink" title="3.0之后APT技术"></a>3.0之后APT技术</h5><p>​	使用<code>EventBusAnnotationProcessor</code>在编译器，遍历所有的类 ，搜集订阅者与订阅方法，最终生成一个实现<code>SubscriberInfoIndex</code>的类，然后在EventBus初始化是调用addIndex方法使用。</p>
<p>使用findUsingInfo查找所有订阅者的订阅方法,思路和3.0之前的版本一直，但是多了一个降级策略.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title function_">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> &#123;</span><br><span class="line">    <span class="type">FindState</span> <span class="variable">findState</span> <span class="operator">=</span> prepareFindState();</span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    <span class="keyword">while</span> (findState.clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">        <span class="keyword">if</span> (findState.subscriberInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                    findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//降级策略</span></span><br><span class="line">            findUsingReflectionInSingleClass(findState);</span><br><span class="line">        &#125;</span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="粘性事件分发"><a href="#粘性事件分发" class="headerlink" title="粘性事件分发"></a>粘性事件分发</h4><p>通过步骤 1， 拿到所有的事件订阅方法，然后进行订阅</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">    	<span class="comment">//步骤2</span></span><br><span class="line">    	subscribe(subscriber, subscriberMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">        <span class="type">Subscription</span> <span class="variable">newSubscription</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subscription</span>(subscriber, subscriberMethod);</span><br><span class="line"><span class="comment">//        获取该事件的所有订阅者</span></span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">        <span class="keyword">if</span> (subscriptions == <span class="literal">null</span>) &#123;</span><br><span class="line">            subscriptions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">            subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不能重复注册</span></span><br><span class="line">            <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;Subscriber &quot;</span> + subscriber.getClass() + <span class="string">&quot; already registered to event &quot;</span></span><br><span class="line">                        + eventType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> subscriptions.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">            <span class="comment">// 优先级高的放在前面，优先级的低放在最后</span></span><br><span class="line">            <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">                subscriptions.add(i, newSubscription);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//订阅者-订阅的所有事件的 映射</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">        <span class="keyword">if</span> (subscribedEvents == <span class="literal">null</span>) &#123;</span><br><span class="line">            subscribedEvents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">        &#125;</span><br><span class="line">        subscribedEvents.add(eventType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.1 有粘性事件时，注册订阅者时直接分发</span></span><br><span class="line">        <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">                <span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></span><br><span class="line">                <span class="comment">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></span><br><span class="line">                <span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></span><br><span class="line">                <span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></span><br><span class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                    <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">stickyEvent</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">                        <span class="comment">//粘性事件分发</span></span><br><span class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//粘性事件分发</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">stickyEvent</span> <span class="operator">=</span> stickyEvents.get(eventType);</span><br><span class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>粘性事件分发</p>
<p>有粘性事件是在注册阶段就判断了是否有响应的订阅者，有的话就<code>checkPostStickyEventToSubscription</code>最终调用到<code>postToSubscription</code>，普通事件的分发最终也是通过<code>postToSubscription</code>，该方法 ，具体的放到后面一起分析</p>
<h4 id="事件发布与分发"><a href="#事件发布与分发" class="headerlink" title="事件发布与分发"></a>事件发布与分发</h4><p>核心逻辑，就是找到事件的订阅者，执行相应的订阅方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6 发送event</span></span><br><span class="line">    <span class="comment">/** Posts the given event to the event bus. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">        <span class="type">PostingThreadState</span> <span class="variable">postingState</span> <span class="operator">=</span> currentPostingThreadState.get();</span><br><span class="line">        List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">        eventQueue.add(event);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">            postingState.isMainThread = isMainThread();</span><br><span class="line">            postingState.isPosting = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;Internal error. Abort state was not reset&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//遍历当前线程的事件队列，一个一个发送</span></span><br><span class="line">                <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                    postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postingState.isPosting = <span class="literal">false</span>;</span><br><span class="line">                postingState.isMainThread = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><code>currentPostingThreadState</code>是一个ThreadLocal变量，它提供线程本地变量，如果创建一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个副本，在实际多线程操作的时候，操作的是自己本地内存中的变量，从而规避了线程安全问题。通常EventBus都是process-wide范围的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PostingThreadState</span> &#123;</span><br><span class="line">    <span class="comment">//存放事件</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; eventQueue = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span> isPosting;</span><br><span class="line">    <span class="comment">//是否是主线程post的</span></span><br><span class="line">    <span class="type">boolean</span> isMainThread;</span><br><span class="line">    <span class="comment">//订阅者和事件处理方法的包装类</span></span><br><span class="line">    Subscription subscription;</span><br><span class="line">    Object event;</span><br><span class="line">    <span class="type">boolean</span> canceled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历eventQueue，从数组头部开始分发，<code>postSingleEvent</code>之后调用到<code>postSingleEventForEventType</code>，取出所有的events(继承的情况)，之后再到<code>postSingleEventForEventType</code>，从缓存中找到所有的订阅者与订阅方法的包装类，使用CopyOnWriteArrayList存放subscriptions，避免遍历时对Suscriber的反注册引起的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6.1 发送单个event，已经找到了eventClass</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> &#123;</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (subscriptions != <span class="literal">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">                postingState.event = event;</span><br><span class="line">                postingState.subscription = subscription;</span><br><span class="line">                <span class="type">boolean</span> aborted;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                    aborted = postingState.canceled;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    postingState.event = <span class="literal">null</span>;</span><br><span class="line">                    postingState.subscription = <span class="literal">null</span>;</span><br><span class="line">                    postingState.canceled = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>遍历分发，最终到<code>postToSubscription</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  7. 分发 event 到 suscription，</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="type">boolean</span> isMainThread)</span> &#123;</span><br><span class="line">        <span class="comment">//按线程模型分发</span></span><br><span class="line">        <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line"><span class="comment">//           在投递的线程处理，没有线程切换，在主线程post，invoke就在主线程</span></span><br><span class="line">            <span class="keyword">case</span> POSTING:</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MAIN:</span><br><span class="line"><span class="comment">//                当前线程是主线程直接调用</span></span><br><span class="line">                <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//                event 总是被排队执行</span></span><br><span class="line">            <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">                <span class="keyword">if</span> (mainThreadPoster != <span class="literal">null</span>) &#123;</span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BACKGROUND:</span><br><span class="line"><span class="comment">//                已经是后台线程就直接执行</span></span><br><span class="line">                <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line"><span class="comment">//                    Executors.newCachedThreadPool()</span></span><br><span class="line">                    backgroundPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ASYNC:</span><br><span class="line">                asyncPoster.enqueue(subscription, event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unknown thread mode: &quot;</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><code>ThreadMode</code>中的<code>POSTING</code>、<code>MAIN</code>、<code>MAIN_ORDERED</code>、<code>BACKGROUND</code>，都可能阻塞post的所在线程，最好不要执行耗时操作。</p>
<p><code>mainThreadPoster</code>底层使用<code>Android</code>的<code>Handler</code>进行分发，<code>backgroundPoster</code>、<code>asyncPoster</code>都是依赖同一个<code>Executors.newCachedThreadPool()</code>进行分发，被分发之后在执行时都是通过<code>invokeSubscriber</code>进行调用。</p>
<p>其中<code>backgroundPoster</code>内部也使用了一个链表queue，使事件按post的顺序执行。</p>
<h4 id="取消注册"><a href="#取消注册" class="headerlink" title="取消注册"></a>取消注册</h4><p>​	</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>框架整体考虑的非常的完善，各种级别的缓存，用空间换时间，避免二次查询，多处使用对象池，避免对象的频繁创建，通过DCL单例提供EventBus对象，使用Builder模式，优化使用大量参数进行初始化。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/android/" rel="tag"><i class="fa fa-tag"></i> android</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/10/12/%E5%9F%BA%E4%BA%8EKotlin-Channel%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/" rel="next" title="基于Kotlin Channel实现任务队列">
                <i class="fa fa-chevron-left"></i> 基于Kotlin Channel实现任务队列
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/11/04/Android-Plugin%E5%BC%80%E5%8F%91-idea%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" rel="prev" title="Android Plugin开发 idea的环境配置">
                Android Plugin开发 idea的环境配置 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="nav-number">2.</span> <span class="nav-text">有什么特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9"><span class="nav-number">3.</span> <span class="nav-text">有什么缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">简单的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84"><span class="nav-number">5.</span> <span class="nav-text">是如何运行的</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">5.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E8%AE%A2%E9%98%85%E8%80%85"><span class="nav-number">5.2.</span> <span class="nav-text">注册订阅者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B6%E9%9B%86%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85"><span class="nav-number">5.3.</span> <span class="nav-text">收集事件订阅</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-0%E4%B9%8B%E5%89%8D%E5%8F%8D%E5%B0%84%E6%96%B9%E5%BC%8F"><span class="nav-number">5.3.1.</span> <span class="nav-text">3.0之前反射方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-0%E4%B9%8B%E5%90%8EAPT%E6%8A%80%E6%9C%AF"><span class="nav-number">5.3.2.</span> <span class="nav-text">3.0之后APT技术</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B2%98%E6%80%A7%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91"><span class="nav-number">5.4.</span> <span class="nav-text">粘性事件分发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E4%B8%8E%E5%88%86%E5%8F%91"><span class="nav-number">5.5.</span> <span class="nav-text">事件发布与分发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%96%E6%B6%88%E6%B3%A8%E5%86%8C"><span class="nav-number">5.6.</span> <span class="nav-text">取消注册</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yndongyong</span>
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>
<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共22.2k字</span>
</div>




        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
